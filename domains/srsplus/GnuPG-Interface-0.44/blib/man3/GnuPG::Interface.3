.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GnuPG::Interface 3"
.TH GnuPG::Interface 3 "2011-05-02" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
GnuPG::Interface \- Perl interface to GnuPG
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # A simple example
\&  use IO::Handle;
\&  use GnuPG::Interface;
.Ve
.PP
.Vb 4
\&  # settting up the situation
\&  my $gnupg = GnuPG::Interface->new();
\&  $gnupg->options->hash_init( armor   => 1,
\&                              homedir => '/home/foobar' );
.Ve
.PP
.Vb 3
\&  # Note you can set the recipients even if you aren't encrypting!
\&  $gnupg->options->push_recipients( 'ftobin@cpan.org' );
\&  $gnupg->options->meta_interactive( 0 );
.Ve
.PP
.Vb 5
\&  # how we create some handles to interact with GnuPG
\&  my $input   = IO::Handle->new();
\&  my $output  = IO::Handle->new();
\&  my $handles = GnuPG::Handles->new( stdin  => $input,
\&                                     stdout => $output );
.Ve
.PP
.Vb 3
\&  # Now we'll go about encrypting with the options already set
\&  my @plaintext = ( 'foobar' );
\&  my $pid = $gnupg->encrypt( handles => $handles );
.Ve
.PP
.Vb 3
\&  # Now we write to the input of GnuPG
\&  print $input @plaintext;
\&  close $input;
.Ve
.PP
.Vb 3
\&  # now we read the output
\&  my @ciphertext = <$output>;
\&  close $output;
.Ve
.PP
.Vb 1
\&  waitpid $pid, 0;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
GnuPG::Interface and its associated modules are designed to
provide an object-oriented method for interacting with GnuPG,
being able to perform functions such as but not limited
to encrypting, signing,
decryption, verification, and key-listing parsing.
.Sh "How Data Member Accessor Methods are Created"
.IX Subsection "How Data Member Accessor Methods are Created"
Each module in the GnuPG::Interface bundle relies
on Any::Moose to generate the get/set methods
used to set the object's data members.
\&\fIThis is very important to realize.\fR  This means that
any data member which is a list has special
methods assigned to it for pushing, popping, and
clearing the list.
.Sh "Understanding Bidirectional Communication"
.IX Subsection "Understanding Bidirectional Communication"
It is also imperative to realize that this package
uses interprocess communication methods similar to
those used in IPC::Open3
and \*(L"Bidirectional Communication with Another Process\*(R" in perlipc,
and that users of this package
need to understand how to use this method because this package
does not abstract these methods for the user greatly.
This package is not designed
to abstract this away entirely (partly for security purposes), but rather
to simply help create 'proper', clean calls to GnuPG, and to implement
key-listing parsing.
Please see \*(L"Bidirectional Communication with Another Process\*(R" in perlipc
to learn how to deal with these methods.
.PP
Using this package to do message processing generally
invovlves creating a GnuPG::Interface object, creating
a GnuPG::Handles object,
setting some options in its \fBoptions\fR data member,
and then calling a method which invokes GnuPG, such as
\&\fBclearsign\fR.  One then interacts with with the handles
appropriately, as described in
\&\*(L"Bidirectional Communication with Another Process\*(R" in perlipc.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.Sh "Initialization Methods"
.IX Subsection "Initialization Methods"
.IP "new( \fI%initialization_args\fR )" 4
.IX Item "new( %initialization_args )"
This methods creates a new object.  The optional arguments are
initialization of data members.
.IP "hash_init( \fI%args\fR )." 4
.IX Item "hash_init( %args )."
.Sh "Object Methods which use a GnuPG::Handles Object"
.IX Subsection "Object Methods which use a GnuPG::Handles Object"
.PD 0
.IP "list_public_keys( % )" 4
.IX Item "list_public_keys( % )"
.IP "list_sigs( % )" 4
.IX Item "list_sigs( % )"
.IP "list_secret_keys( % )" 4
.IX Item "list_secret_keys( % )"
.IP "encrypt( % )" 4
.IX Item "encrypt( % )"
.IP "encrypt_symmetrically( % )" 4
.IX Item "encrypt_symmetrically( % )"
.IP "sign( % )" 4
.IX Item "sign( % )"
.IP "clearsign( % )" 4
.IX Item "clearsign( % )"
.IP "detach_sign( % )" 4
.IX Item "detach_sign( % )"
.IP "sign_and_encrypt( % )" 4
.IX Item "sign_and_encrypt( % )"
.IP "decrypt( % )" 4
.IX Item "decrypt( % )"
.IP "verify( % )" 4
.IX Item "verify( % )"
.IP "import_keys( % )" 4
.IX Item "import_keys( % )"
.IP "export_keys( % )" 4
.IX Item "export_keys( % )"
.IP "recv_keys( % )" 4
.IX Item "recv_keys( % )"
.IP "send_keys( % )" 4
.IX Item "send_keys( % )"
.PD
These methods each correspond directly to or are very similar
to a GnuPG command described in gpg.  Each of these methods
takes a hash, which currently must contain a key of \fBhandles\fR
which has the value of a GnuPG::Handles object.
Another optional key is \fBcommand_args\fR which should have the value of an
array reference; these arguments will be passed to GnuPG as command arguments.
These command arguments are used for such things as determining the keys to
list in the \fBexport_keys\fR method.  \fIPlease note that GnuPG command arguments
are not the same as GnuPG options\fR.  To understand what are options and
what are command arguments please read \*(L"\s-1COMMANDS\s0\*(R" in gpg and \*(L"\s-1OPTIONS\s0\*(R" in gpg.
.Sp
Each of these calls returns the \s-1PID\s0 for the resulting GnuPG process.
One can use this \s-1PID\s0 in a \f(CW\*(C`waitpid\*(C'\fR call instead of a \f(CW\*(C`wait\*(C'\fR call
if more precise process reaping is needed.
.Sp
These methods will attach the handles specified in the \fBhandles\fR object
to the running GnuPG object, so that bidirectional communication
can be established.  That is, the optionally-defined \fBstdin\fR,
\&\fBstdout\fR, \fBstderr\fR, \fBstatus\fR, \fBlogger\fR, and
\&\fBpassphrase\fR handles will be attached to
GnuPG's input, output, standard error,
the handle created by setting \fBstatus-fd\fR, the handle created by setting \fBlogger-fd\fR, and the handle created by setting
\&\fBpassphrase-fd\fR respectively.
This tying of handles of similar to the process
done in \fIIPC::Open3\fR.
.Sp
If you want the GnuPG process to read or write directly to an already-opened
filehandle, you cannot do this via the normal \fIIPC::Open3\fR mechanisms.
In order to accomplish this, set the appropriate \fBhandles\fR data member
to the already-opened filehandle, and then set the option \fBdirect\fR to be true
for that handle, as described in \*(L"options\*(R" in GnuPG::Handles.  For example,
to have GnuPG read from the file \fIinput.txt\fR and write to \fIoutput.txt\fR,
the following snippet may do:
.Sp
.Vb 7
\&  my $infile  = IO::File->new( 'input.txt' );
\&  my $outfile = IO::File->new( '>output.txt' );
\&  my $handles = GnuPG::Handles->new( stdin  => $infile,
\&                                     stdout => $outfile,
\&                                   );
\&  $handles->options( 'stdin'  )->{direct} = 1;
\&  $handles->options( 'stdout' )->{direct} = 1;
.Ve
.Sp
If any handle in the \fBhandles\fR object is not defined, GnuPG's input, output,
and standard error will be tied to the running program's standard error,
standard output, or standard error.  If the \fBstatus\fR or \fBlogger\fR handle
is not defined, this channel of communication is never established with GnuPG,
and so this information is not generated and does not come into play.
If the \fBpassphrase\fR data member handle of the \fBhandles\fR object
is not defined, but the the \fBpassphrase\fR data member handle of GnuPG::Interface
object is, GnuPG::Interface will handle passing this information into GnuPG
for the user as a convience.  Note that this will result in
GnuPG::Interface storing the passphrase in memory, instead of having
it simply 'pass\-through' to GnuPG via a handle.
.Sh "Other Methods"
.IX Subsection "Other Methods"
.ie n .IP "get_public_keys( @search_strings )" 4
.el .IP "get_public_keys( \f(CW@search_strings\fR )" 4
.IX Item "get_public_keys( @search_strings )"
.PD 0
.ie n .IP "get_secret_keys( @search_strings )" 4
.el .IP "get_secret_keys( \f(CW@search_strings\fR )" 4
.IX Item "get_secret_keys( @search_strings )"
.ie n .IP "get_public_keys_with_sigs( @search_strings )" 4
.el .IP "get_public_keys_with_sigs( \f(CW@search_strings\fR )" 4
.IX Item "get_public_keys_with_sigs( @search_strings )"
.PD
These methods create and return objects of the type GnuPG::PublicKey
or GnuPG::SecretKey respectively.  This is done by parsing the output
of GnuPG with the option \fBwith-colons\fR enabled.  The objects created
do or do not have signature information stored in them, depending
if the method ends in \fI_sigs\fR; this separation of functionality is there
because of performance hits when listing information with signatures.
.IP "\fItest_default_key_passphrase()\fR" 4
.IX Item "test_default_key_passphrase()"
This method will return a true or false value, depending
on whether GnuPG reports a good passphrase was entered
while signing a short message using the values of
the \fBpassphrase\fR data member, and the default
key specified in the \fBoptions\fR data member.
.SH "Invoking GnuPG with a custom call"
.IX Header "Invoking GnuPG with a custom call"
GnuPG::Interface attempts to cover a lot of the commands
of GnuPG that one would want to perform; however, there may be a lot
more calls that GnuPG is and will be capable of, so a generic command
interface is provided, \f(CW\*(C`wrap_call\*(C'\fR.
.ie n .IP "wrap_call( %args )" 4
.el .IP "wrap_call( \f(CW%args\fR )" 4
.IX Item "wrap_call( %args )"
Call GnuPG with a custom command.  The \f(CW%args\fR hash must contain
at least the following keys:
.RS 4
.IP "commands" 4
.IX Item "commands"
The value of this key in the hash must be a reference to a a list of
commands for GnuPG, such as \f(CW\*(C`[ qw( \-\-encrypt \-\-sign ) ]\*(C'\fR.
.IP "handles" 4
.IX Item "handles"
As with most other GnuPG::Interface methods, \fBhandles\fR
must be a GnuPG::Handles object.
.RE
.RS 4
.Sp
The following keys are optional.
.IP "command_args" 4
.IX Item "command_args"
As with other GnuPG::Interface methods, the value in hash
for this key must be a reference to a list of arguments
to be passed to the GnuPG command, such as which
keys to list in a key\-listing.
.RE
.RS 4
.RE
.SH "OBJECT DATA MEMBERS"
.IX Header "OBJECT DATA MEMBERS"
.IP "call" 4
.IX Item "call"
This defines the call made to invoke GnuPG.  Defaults to 'gpg'; this
should be changed if 'gpg' is not in your path, or there is a different
name for the binary on your system.
.IP "passphrase" 4
.IX Item "passphrase"
In order to lessen the burden of using handles by the user of this package,
setting this option to one's passphrase for a secret key will allow
the package to enter the passphrase via a handle to GnuPG by itself
instead of leaving this to the user.  See also \*(L"passphrase\*(R" in GnuPG::Handles.
.IP "options" 4
.IX Item "options"
This data member, of the type GnuPG::Options; the setting stored in this
data member are used to determine the options used when calling GnuPG
via \fIany\fR of the object methods described in this package.
See GnuPG::Options for more information.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following setup can be done before any of the following examples:
.PP
.Vb 2
\&  use IO::Handle;
\&  use GnuPG::Interface;
.Ve
.PP
.Vb 2
\&  my @original_plaintext = ( "How do you doo?" );
\&  my $passphrase = "Three Little Pigs";
.Ve
.PP
.Vb 1
\&  my $gnupg = GnuPG::Interface->new();
.Ve
.PP
.Vb 5
\&  $gnupg->options->hash_init( armor    => 1,
\&                              recipients => [ 'ftobin@uiuc.edu',
\&                                              '0xABCD1234' ],
\&                              meta_interactive( 0 ),
\&                            );
.Ve
.Sh "Encrypting"
.IX Subsection "Encrypting"
.Vb 5
\&  # We'll let the standard error of GnuPG pass through
\&  # to our own standard error, by not creating
\&  # a stderr-part of the $handles object.
\&  my ( $input, $output ) = ( IO::Handle->new(),
\&                             IO::Handle->new() );
.Ve
.PP
.Vb 2
\&  my $handles = GnuPG::Handles->new( stdin    => $input,
\&                                     stdout   => $output );
.Ve
.PP
.Vb 4
\&  # this sets up the communication
\&  # Note that the recipients were specified earlier
\&  # in the 'options' data member of the $gnupg object.
\&  my $pid = $gnupg->encrypt( handles => $handles );
.Ve
.PP
.Vb 2
\&  # this passes in the plaintext
\&  print $input @original_plaintext;
.Ve
.PP
.Vb 3
\&  # this closes the communication channel,
\&  # indicating we are done
\&  close $input;
.Ve
.PP
.Vb 1
\&  my @ciphertext = <$output>;  # reading the output
.Ve
.PP
.Vb 1
\&  waitpid $pid, 0;  # clean up the finished GnuPG process
.Ve
.Sh "Signing"
.IX Subsection "Signing"
.Vb 5
\&  # This time we'll catch the standard error for our perusing
\&  my ( $input, $output, $error ) = ( IO::Handle->new(),
\&                                     IO::Handle->new(),
\&                                     IO::Handle->new(),
\&                                   );
.Ve
.PP
.Vb 4
\&  my $handles = GnuPG::Handles->new( stdin    => $input,
\&                                     stdout   => $output,
\&                                     stderr   => $error,
\&                                   );
.Ve
.PP
.Vb 3
\&  # indicate our pasphrase through the
\&  # convience method
\&  $gnupg->passphrase( $passphrase );
.Ve
.PP
.Vb 2
\&  # this sets up the communication
\&  my $pid = $gnupg->sign( handles => $handles );
.Ve
.PP
.Vb 2
\&  # this passes in the plaintext
\&  print $input @original_plaintext;
.Ve
.PP
.Vb 3
\&  # this closes the communication channel,
\&  # indicating we are done
\&  close $input;
.Ve
.PP
.Vb 2
\&  my @ciphertext   = <$output>;  # reading the output
\&  my @error_output = <$error>;   # reading the error
.Ve
.PP
.Vb 2
\&  close $output;
\&  close $error;
.Ve
.PP
.Vb 1
\&  waitpid $pid, 0;  # clean up the finished GnuPG process
.Ve
.Sh "Decryption"
.IX Subsection "Decryption"
.Vb 10
\&  # This time we'll catch the standard error for our perusing
\&  # as well as passing in the passphrase manually
\&  # as well as the status information given by GnuPG
\&  my ( $input, $output, $error, $passphrase_fh, $status_fh )
\&    = ( IO::Handle->new(),
\&        IO::Handle->new(),
\&        IO::Handle->new(),
\&        IO::Handle->new(),
\&        IO::Handle->new(),
\&      );
.Ve
.PP
.Vb 6
\&  my $handles = GnuPG::Handles->new( stdin      => $input,
\&                                     stdout     => $output,
\&                                     stderr     => $error,
\&                                     passphrase => $passphrase_fh,
\&                                     status     => $status_fh,
\&                                   );
.Ve
.PP
.Vb 4
\&  # this time we'll also demonstrate decrypting
\&  # a file written to disk
\&  # Make sure you "use IO::File" if you use this module!
\&  my $cipher_file = IO::File->new( 'encrypted.gpg' );
.Ve
.PP
.Vb 2
\&  # this sets up the communication
\&  my $pid = $gnupg->decrypt( handles => $handles );
.Ve
.PP
.Vb 3
\&  # This passes in the passphrase
\&  print $passphrase_fh $passphrase;
\&  close $passphrase_fh;
.Ve
.PP
.Vb 2
\&  # this passes in the plaintext
\&  print $input $_ while <$cipher_file>;
.Ve
.PP
.Vb 4
\&  # this closes the communication channel,
\&  # indicating we are done
\&  close $input;
\&  close $cipher_file;
.Ve
.PP
.Vb 3
\&  my @plaintext    = <$output>;   # reading the output
\&  my @error_output = <$error>;    # reading the error
\&  my @status_info  = <$status_fh> # read the status info
.Ve
.PP
.Vb 4
\&  # clean up...
\&  close $output;
\&  close $error;
\&  close $status_fh;
.Ve
.PP
.Vb 1
\&  waitpid $pid, 0;  # clean up the finished GnuPG process
.Ve
.Sh "Printing Keys"
.IX Subsection "Printing Keys"
.Vb 3
\&  # This time we'll just let GnuPG print to our own output
\&  # and read from our input, because no input is needed!
\&  my $handles = GnuPG::Handles->new();
.Ve
.PP
.Vb 1
\&  my @ids = ( 'ftobin', '0xABCD1234' );
.Ve
.PP
.Vb 5
\&  # this time we need to specify something for
\&  # command_args because --list-public-keys takes
\&  # search ids as arguments
\&  my $pid = $gnupg->list_public_keys( handles      => $handles,
\&                                      command_args => [ @ids ] );
.Ve
.PP
.Vb 1
\&   waitpid $pid, 0;
.Ve
.Sh "Creating GnuPG::PublicKey Objects"
.IX Subsection "Creating GnuPG::PublicKey Objects"
.Vb 1
\&  my @ids = [ 'ftobin', '0xABCD1234' ];
.Ve
.PP
.Vb 1
\&  my @keys = $gnupg->get_public_keys( @ids );
.Ve
.PP
.Vb 2
\&  # no wait is required this time; it's handled internally
\&  # since the entire call is encapsulated
.Ve
.Sh "Custom GnuPG call"
.IX Subsection "Custom GnuPG call"
.Vb 6
\&  # assuming $handles is a GnuPG::Handles object
\&  my $pid = $gnupg->wrap_call
\&    ( commands     => [ qw( --list-packets ) ],
\&      command_args => [ qw( test/key.1.asc ) ],
\&      handles      => $handles,
\&    );
.Ve
.PP
.Vb 2
\&    my @out = <$handles->stdout()>;
\&    waitpid $pid, 0;
.Ve
.SH "FAQ"
.IX Header "FAQ"
.IP "How do I get GnuPG::Interface to read/write directly from a filehandle?" 4
.IX Item "How do I get GnuPG::Interface to read/write directly from a filehandle?"
You need to set GnuPG::Handles \fBdirect\fR option to be true for the
filehandles in concern.  See \*(L"options\*(R" in GnuPG::Handles and
\&\*(L"Object Methods which use a GnuPG::Handles Object\*(R" for more
information.
.IP "Why do you make it so difficult to get GnuPG to write/read from a filehandle?  In the shell, I can just call GnuPG with the \-\-outfile option!" 4
.IX Item "Why do you make it so difficult to get GnuPG to write/read from a filehandle?  In the shell, I can just call GnuPG with the --outfile option!"
There are lots of issues when trying to tell GnuPG to read/write
directly from a file, such as if the file isn't there, or
there is a file, and you want to write over it!  What do you
want to happen then?  Having the user of this module handle
these questions beforehand by opening up filehandles to GnuPG
lets the user know fully what is going to happen in these circumstances,
and makes the module less error\-prone.
.IP "When having GnuPG process a large message, sometimes it just hanges there." 4
.IX Item "When having GnuPG process a large message, sometimes it just hanges there."
Your problem may be due to buffering issues; when GnuPG reads/writes
to \fBnon-direct\fR filehandles (those that are sent to filehandles
which you read to from into memory, not that those access the disk),
buffering issues can mess things up.  I recommend looking into
\&\*(L"options\*(R" in GnuPG::Handles.
.SH "NOTES"
.IX Header "NOTES"
This package is the successor to PGP::GPG::MessageProcessor,
which I found to be too inextensible to carry on further.
A total redesign was needed, and this is the resulting
work.
.PP
After any call to a GnuPG-command method of GnuPG::Interface
in which one passes in the handles,
one should all \fBwait\fR to clean up GnuPG from the process table.
.SH "BUGS"
.IX Header "BUGS"
Currently there are problems when transmitting large quantities
of information over handles; I'm guessing this is due
to buffering issues.  This bug does not seem specific to this package;
IPC::Open3 also appears affected.
.PP
I don't know yet how well this modules handles parsing OpenPGP v3 keys.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
GnuPG::Options,
GnuPG::Handles,
GnuPG::PublicKey,
GnuPG::SecretKey,
gpg,
\&\*(L"Bidirectional Communication with Another Process\*(R" in perlipc
.SH "AUTHOR"
.IX Header "AUTHOR"
GnuPg::Interface is currently maintained by Jesse Vincent <jesse@cpan.org>.  
.PP
Frank J. Tobin, ftobin@cpan.org was the original author of the package.
